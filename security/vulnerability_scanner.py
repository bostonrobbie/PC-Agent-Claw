"""
Security Vulnerability Scanner
Comprehensive security analysis tool for detecting vulnerabilities and enforcing security best practices.
Features: SQL injection detection, XSS prevention, dependency scanning, OWASP Top 10 detection, etc.
"""

import sqlite3
import re
import json
import hashlib
import datetime
from pathlib import Path
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import ast
import subprocess


class VulnerabilityType(Enum):
    """Enumeration of vulnerability types."""
    SQL_INJECTION = "SQL_INJECTION"
    XSS = "XSS"
    AUTHENTICATION_BYPASS = "AUTHENTICATION_BYPASS"
    INSECURE_DESERIALIZATION = "INSECURE_DESERIALIZATION"
    BROKEN_ACCESS_CONTROL = "BROKEN_ACCESS_CONTROL"
    SENSITIVE_DATA_EXPOSURE = "SENSITIVE_DATA_EXPOSURE"
    SECURITY_MISCONFIGURATION = "SECURITY_MISCONFIGURATION"
    INSECURE_DEPENDENCIES = "INSECURE_DEPENDENCIES"
    INSUFFICIENT_LOGGING = "INSUFFICIENT_LOGGING"
    WEAK_CRYPTOGRAPHY = "WEAK_CRYPTOGRAPHY"
    HARDCODED_SECRETS = "HARDCODED_SECRETS"
    UNSAFE_HTTP = "UNSAFE_HTTP"
    BUFFER_OVERFLOW = "BUFFER_OVERFLOW"
    PATH_TRAVERSAL = "PATH_TRAVERSAL"
    INSECURE_RANDOM = "INSECURE_RANDOM"


class SeverityLevel(Enum):
    """Enumeration of severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class Vulnerability:
    """Data class representing a vulnerability."""
    id: str
    name: str
    type: str
    severity: str
    file: str
    line: int
    code_snippet: str
    description: str
    fix_suggestion: str
    cwe_id: str
    owasp_top10: str
    timestamp: str
    hash: str


class SecurityDatabase:
    """Database manager for vulnerability storage and reporting."""

    def __init__(self, db_path: str = "security_scanner.db"):
        """Initialize the security database."""
        self.db_path = db_path
        self.init_database()

    def init_database(self):
        """Initialize the database schema."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Vulnerabilities table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                type TEXT NOT NULL,
                severity TEXT NOT NULL,
                file TEXT NOT NULL,
                line INTEGER,
                code_snippet TEXT,
                description TEXT,
                fix_suggestion TEXT,
                cwe_id TEXT,
                owasp_top10 TEXT,
                timestamp TEXT NOT NULL,
                hash TEXT UNIQUE
            )
        """)

        # Fix history table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS fix_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vulnerability_id TEXT NOT NULL,
                fix_applied TEXT,
                timestamp TEXT NOT NULL,
                FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities(id)
            )
        """)

        # Scan reports table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS scan_reports (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_timestamp TEXT NOT NULL,
                total_vulnerabilities INTEGER,
                critical_count INTEGER,
                high_count INTEGER,
                medium_count INTEGER,
                low_count INTEGER,
                info_count INTEGER,
                files_scanned INTEGER,
                report_json TEXT
            )
        """)

        conn.commit()
        conn.close()

    def save_vulnerability(self, vuln: Vulnerability) -> bool:
        """Save a vulnerability to the database."""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR IGNORE INTO vulnerabilities
                (id, name, type, severity, file, line, code_snippet, description,
                 fix_suggestion, cwe_id, owasp_top10, timestamp, hash)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (vuln.id, vuln.name, vuln.type, vuln.severity, vuln.file, vuln.line,
                  vuln.code_snippet, vuln.description, vuln.fix_suggestion,
                  vuln.cwe_id, vuln.owasp_top10, vuln.timestamp, vuln.hash))
            conn.commit()
            conn.close()
            return True
        except sqlite3.IntegrityError:
            return False

    def get_vulnerabilities(self, severity: Optional[str] = None) -> List[Dict]:
        """Retrieve vulnerabilities from the database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        if severity:
            cursor.execute(
                "SELECT * FROM vulnerabilities WHERE severity = ? ORDER BY timestamp DESC",
                (severity,)
            )
        else:
            cursor.execute("SELECT * FROM vulnerabilities ORDER BY timestamp DESC")

        columns = [desc[0] for desc in cursor.description]
        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
        conn.close()
        return results

    def save_scan_report(self, vulnerabilities: List[Vulnerability]) -> int:
        """Save a complete scan report."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        severity_counts = {level.value: 0 for level in SeverityLevel}
        for vuln in vulnerabilities:
            severity_counts[vuln.severity] += 1

        report_json = json.dumps([asdict(v) for v in vulnerabilities])

        cursor.execute("""
            INSERT INTO scan_reports
            (scan_timestamp, total_vulnerabilities, critical_count, high_count,
             medium_count, low_count, info_count, files_scanned, report_json)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            datetime.datetime.now().isoformat(),
            len(vulnerabilities),
            severity_counts["CRITICAL"],
            severity_counts["HIGH"],
            severity_counts["MEDIUM"],
            severity_counts["LOW"],
            severity_counts["INFO"],
            len(set(v.file for v in vulnerabilities)),
            report_json
        ))

        report_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return report_id

    def get_scan_reports(self, limit: int = 10) -> List[Dict]:
        """Retrieve scan reports."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM scan_reports ORDER BY scan_timestamp DESC LIMIT ?
        """, (limit,))

        columns = [desc[0] for desc in cursor.description]
        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
        conn.close()
        return results


class PatternMatcher:
    """Pattern matching for security vulnerabilities."""

    # SQL Injection patterns
    SQL_INJECTION_PATTERNS = [
        r"execute\s*\(\s*['\"].*\+",  # String concatenation in execute
        r"format\s*\(\s*['\"][^'\"]*\{.*\}",  # String format with variables
        r"query\s*=\s*['\"].*\+\s*[a-zA-Z_]",  # Query concatenation
        r"SELECT\s+.*\+\s*[a-zA-Z_]",  # SELECT with concatenation
        r"WHERE\s+.*=\s*['\"].*\+",  # WHERE clause concatenation
    ]

    # XSS patterns
    XSS_PATTERNS = [
        r"innerHTML\s*=",  # innerHTML assignment
        r"eval\s*\(",  # eval usage
        r"dangerouslySetInnerHTML",  # React dangerous HTML
        r"\.html\s*\(",  # jQuery html()
        r"document\.write\s*\(",  # document.write
        r"\$\(.*\)\.html\s*\(",  # jQuery chain
    ]

    # Authentication bypass patterns
    AUTH_PATTERNS = [
        r"password\s*==\s*['\"][^'\"]+['\"]",  # Hardcoded password
        r"token\s*==\s*['\"][^'\"]+['\"]",  # Hardcoded token
        r"if\s+.*admin\s*:\s*return\s+True",  # Always return True
        r"def\s+.*auth.*:.*return\s+True",  # Authentication function returns True
    ]

    # Hardcoded secrets patterns
    SECRETS_PATTERNS = [
        r"(api_key|apikey|api-key)\s*=\s*['\"]([^'\"]+)['\"]",
        r"(password|passwd|pwd)\s*=\s*['\"]([^'\"]+)['\"]",
        r"(secret|token|access_token)\s*=\s*['\"]([^'\"]+)['\"]",
        r"(database_url|db_url)\s*=\s*['\"]([^'\"]+)['\"]",
    ]

    # Weak cryptography patterns
    CRYPTO_PATTERNS = [
        r"md5\s*\(",  # MD5 usage
        r"sha1\s*\(",  # SHA1 usage
        r"hashlib\.md5",  # Python MD5
        r"hashlib\.sha1",  # Python SHA1
        r"random\s*\(",  # weak random
    ]

    # Path traversal patterns
    PATH_TRAVERSAL_PATTERNS = [
        r"open\s*\(\s*['\"].*\+\s*user_input",  # File open with concatenation
        r"\.replace\s*\(\s*['\"]\\+['\"]",  # Path manipulation
        r"os\.path\.join\s*\(\s*['\"].*['\"].*user",  # Path join with user input
    ]

    # Insecure HTTP patterns
    HTTP_PATTERNS = [
        r"http://[^s]",  # Non-HTTPS URLs
        r"requests\.get\s*\(\s*['\"]http://",  # HTTP requests
    ]

    @staticmethod
    def find_pattern_matches(code: str, patterns: List[str], flags: int = re.IGNORECASE) -> List[Tuple[int, str]]:
        """Find pattern matches in code with line numbers."""
        matches = []
        lines = code.split('\n')

        for line_num, line in enumerate(lines, 1):
            for pattern in patterns:
                if re.search(pattern, line, flags):
                    matches.append((line_num, line.strip()))

        return matches


class DependencyScanner:
    """Scanner for vulnerable dependencies."""

    KNOWN_VULNERABLE_PACKAGES = {
        'requests': {'vulnerable_versions': ['<2.20.0'], 'cve': 'CVE-2018-18074'},
        'django': {'vulnerable_versions': ['<2.1.5'], 'cve': 'CVE-2018-16984'},
        'flask': {'vulnerable_versions': ['<1.0'], 'cve': 'CVE-2018-1000656'},
        'urllib3': {'vulnerable_versions': ['<1.24.2'], 'cve': 'CVE-2019-9740'},
        'pyyaml': {'vulnerable_versions': ['<5.1'], 'cve': 'CVE-2017-18342'},
        'jinja2': {'vulnerable_versions': ['<2.10.3'], 'cve': 'CVE-2019-10906'},
        'pillow': {'vulnerable_versions': ['<6.0'], 'cve': 'CVE-2019-6552'},
    }

    @staticmethod
    def check_requirements_file(requirements_path: str) -> List[Dict]:
        """Check requirements.txt for vulnerable packages."""
        vulnerabilities = []

        if not Path(requirements_path).exists():
            return vulnerabilities

        with open(requirements_path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Parse package and version
                match = re.match(r'([a-zA-Z0-9\-_.]+)([<>=!]*)(.*)', line)
                if match:
                    package_name, operator, version = match.groups()
                    package_name = package_name.lower()

                    if package_name in DependencyScanner.KNOWN_VULNERABLE_PACKAGES:
                        vuln_info = DependencyScanner.KNOWN_VULNERABLE_PACKAGES[package_name]
                        vulnerabilities.append({
                            'package': package_name,
                            'version': version,
                            'vulnerability': vuln_info['cve'],
                            'fix': f"Update {package_name} to latest version"
                        })

        return vulnerabilities

    @staticmethod
    def get_pip_audit_results() -> List[Dict]:
        """Get vulnerability results from pip-audit if available."""
        try:
            result = subprocess.run(['pip-audit', '--json'], capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except (FileNotFoundError, subprocess.TimeoutExpired, json.JSONDecodeError):
            pass

        return []


class SecurityBestPractices:
    """Enforce security best practices."""

    BEST_PRACTICES = {
        'input_validation': {
            'pattern': r'def\s+[^(]+\([^)]*\).*?(?!input\s*validation)',
            'message': 'Input validation not found in function',
        },
        'error_handling': {
            'pattern': r'try:(?!.*except)',
            'message': 'Try block without exception handling',
        },
        'secure_headers': {
            'pattern': r'add_header\s+X-Content-Type-Options|secure_headers',
            'message': 'Secure HTTP headers not set',
        },
        'csrf_protection': {
            'pattern': r'csrf_token|@csrf_exempt',
            'message': 'CSRF protection might be missing',
        },
        'rate_limiting': {
            'pattern': r'rate_limit|ratelimit|@limiter',
            'message': 'Rate limiting not implemented',
        },
        'logging_security_events': {
            'pattern': r'logger\.(warning|error|critical).*security',
            'message': 'Security events not properly logged',
        },
        'tls_verification': {
            'pattern': r'verify\s*=\s*False',
            'message': 'TLS certificate verification disabled',
        },
    }

    @staticmethod
    def check_best_practices(code: str) -> List[Dict]:
        """Check for security best practices."""
        issues = []

        for practice, details in SecurityBestPractices.BEST_PRACTICES.items():
            if not re.search(details['pattern'], code, re.IGNORECASE | re.DOTALL):
                issues.append({
                    'practice': practice,
                    'message': details['message'],
                    'severity': 'MEDIUM'
                })

        return issues


class VulnerabilityScanner:
    """Main vulnerability scanner combining all security checks."""

    def __init__(self, db_path: str = "security_scanner.db"):
        """Initialize the scanner."""
        self.db = SecurityDatabase(db_path)
        self.vulnerabilities = []

    def scan_file(self, file_path: str) -> List[Vulnerability]:
        """Scan a single file for vulnerabilities."""
        self.vulnerabilities = []

        if not Path(file_path).exists():
            return []

        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                code = f.read()
        except Exception as e:
            print(f"Error reading file {file_path}: {e}")
            return []

        # Run all security checks
        self._check_sql_injection(code, file_path)
        self._check_xss(code, file_path)
        self._check_auth_bypass(code, file_path)
        self._check_hardcoded_secrets(code, file_path)
        self._check_weak_cryptography(code, file_path)
        self._check_path_traversal(code, file_path)
        self._check_insecure_http(code, file_path)
        self._check_best_practices(code, file_path)
        self._check_insecure_deserialization(code, file_path)
        self._check_access_control(code, file_path)

        return self.vulnerabilities

    def _check_sql_injection(self, code: str, file_path: str):
        """Check for SQL injection vulnerabilities."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.SQL_INJECTION_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('sql_injection', file_path, line_num),
                name="SQL Injection Vulnerability",
                type=VulnerabilityType.SQL_INJECTION.value,
                severity=SeverityLevel.CRITICAL.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="SQL injection vulnerability detected due to string concatenation in SQL queries",
                fix_suggestion="Use parameterized queries/prepared statements with placeholders (?) instead of string concatenation",
                cwe_id="CWE-89",
                owasp_top10="A03:2021 - Injection",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'sql_injection')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_xss(self, code: str, file_path: str):
        """Check for XSS vulnerabilities."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.XSS_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('xss', file_path, line_num),
                name="Cross-Site Scripting (XSS) Vulnerability",
                type=VulnerabilityType.XSS.value,
                severity=SeverityLevel.HIGH.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="XSS vulnerability detected due to unsafe HTML injection",
                fix_suggestion="Use proper escaping/encoding, sanitize user input, use Content Security Policy (CSP)",
                cwe_id="CWE-79",
                owasp_top10="A07:2021 - Cross-Site Scripting (XSS)",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'xss')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_auth_bypass(self, code: str, file_path: str):
        """Check for authentication bypass vulnerabilities."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.AUTH_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('auth_bypass', file_path, line_num),
                name="Authentication Bypass Vulnerability",
                type=VulnerabilityType.AUTHENTICATION_BYPASS.value,
                severity=SeverityLevel.CRITICAL.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="Potential authentication bypass detected",
                fix_suggestion="Use secure password hashing, multi-factor authentication, and proper session management",
                cwe_id="CWE-287",
                owasp_top10="A07:2021 - Identification and Authentication Failures",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'auth_bypass')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_hardcoded_secrets(self, code: str, file_path: str):
        """Check for hardcoded secrets."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.SECRETS_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('hardcoded_secrets', file_path, line_num),
                name="Hardcoded Secrets",
                type=VulnerabilityType.HARDCODED_SECRETS.value,
                severity=SeverityLevel.CRITICAL.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="Hardcoded secrets (API keys, passwords, tokens) detected in source code",
                fix_suggestion="Move secrets to environment variables, use secret management tools (Vault, AWS Secrets Manager)",
                cwe_id="CWE-798",
                owasp_top10="A02:2021 - Cryptographic Failures",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'hardcoded_secrets')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_weak_cryptography(self, code: str, file_path: str):
        """Check for weak cryptography."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.CRYPTO_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('weak_crypto', file_path, line_num),
                name="Weak Cryptography",
                type=VulnerabilityType.WEAK_CRYPTOGRAPHY.value,
                severity=SeverityLevel.HIGH.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="Weak cryptographic algorithm detected (MD5, SHA1, weak random)",
                fix_suggestion="Use strong algorithms like SHA-256, SHA-3, or bcrypt. Use os.urandom() or secrets module for randomness",
                cwe_id="CWE-327",
                owasp_top10="A02:2021 - Cryptographic Failures",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'weak_crypto')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_path_traversal(self, code: str, file_path: str):
        """Check for path traversal vulnerabilities."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.PATH_TRAVERSAL_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('path_traversal', file_path, line_num),
                name="Path Traversal Vulnerability",
                type=VulnerabilityType.PATH_TRAVERSAL.value,
                severity=SeverityLevel.HIGH.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="Potential path traversal vulnerability detected",
                fix_suggestion="Validate and sanitize file paths, use os.path.basename(), restrict file operations to specific directories",
                cwe_id="CWE-22",
                owasp_top10="A01:2021 - Broken Access Control",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'path_traversal')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_insecure_http(self, code: str, file_path: str):
        """Check for insecure HTTP usage."""
        matches = PatternMatcher.find_pattern_matches(code, PatternMatcher.HTTP_PATTERNS)

        for line_num, code_snippet in matches:
            vuln = Vulnerability(
                id=self._generate_id('insecure_http', file_path, line_num),
                name="Insecure HTTP Usage",
                type=VulnerabilityType.UNSAFE_HTTP.value,
                severity=SeverityLevel.MEDIUM.value,
                file=file_path,
                line=line_num,
                code_snippet=code_snippet,
                description="Insecure HTTP connection detected. HTTPS should be used instead",
                fix_suggestion="Use HTTPS instead of HTTP for all network communications",
                cwe_id="CWE-295",
                owasp_top10="A02:2021 - Cryptographic Failures",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, line_num, 'insecure_http')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_best_practices(self, code: str, file_path: str):
        """Check security best practices."""
        issues = SecurityBestPractices.check_best_practices(code)

        for issue in issues:
            vuln = Vulnerability(
                id=self._generate_id('best_practice', file_path, 0),
                name=f"Security Best Practice: {issue['practice']}",
                type=VulnerabilityType.SECURITY_MISCONFIGURATION.value,
                severity=issue['severity'],
                file=file_path,
                line=0,
                code_snippet="",
                description=issue['message'],
                fix_suggestion=f"Implement {issue['practice']} for better security",
                cwe_id="CWE-1021",
                owasp_top10="A05:2021 - Security Misconfiguration",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, 0, issue['practice'])
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_insecure_deserialization(self, code: str, file_path: str):
        """Check for insecure deserialization."""
        if re.search(r'pickle\.(loads|load)|yaml\.(unsafe_load|load)', code, re.IGNORECASE):
            vuln = Vulnerability(
                id=self._generate_id('insecure_deserialization', file_path, 0),
                name="Insecure Deserialization",
                type=VulnerabilityType.INSECURE_DESERIALIZATION.value,
                severity=SeverityLevel.CRITICAL.value,
                file=file_path,
                line=0,
                code_snippet="",
                description="Insecure deserialization detected (pickle.loads or yaml.unsafe_load)",
                fix_suggestion="Use safe deserialization methods like json.loads or yaml.safe_load",
                cwe_id="CWE-502",
                owasp_top10="A08:2021 - Software and Data Integrity Failures",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, 0, 'insecure_deserialization')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def _check_access_control(self, code: str, file_path: str):
        """Check for broken access control."""
        if re.search(r'@.*\.route.*|def.*\(.*\).*:', code) and not re.search(r'@.*login_required|@.*permission', code):
            vuln = Vulnerability(
                id=self._generate_id('broken_access_control', file_path, 0),
                name="Broken Access Control",
                type=VulnerabilityType.BROKEN_ACCESS_CONTROL.value,
                severity=SeverityLevel.HIGH.value,
                file=file_path,
                line=0,
                code_snippet="",
                description="Routes or endpoints may lack proper access control checks",
                fix_suggestion="Implement proper authentication and authorization checks using decorators or middleware",
                cwe_id="CWE-284",
                owasp_top10="A01:2021 - Broken Access Control",
                timestamp=datetime.datetime.now().isoformat(),
                hash=self._generate_hash(file_path, 0, 'broken_access_control')
            )
            self.vulnerabilities.append(vuln)
            self.db.save_vulnerability(vuln)

    def scan_directory(self, directory: str, file_extensions: List[str] = None) -> List[Vulnerability]:
        """Scan a directory for vulnerabilities."""
        if file_extensions is None:
            file_extensions = ['.py', '.js', '.java', '.php', '.cs']

        all_vulnerabilities = []
        path = Path(directory)

        for ext in file_extensions:
            for file_path in path.rglob(f'*{ext}'):
                try:
                    vulnerabilities = self.scan_file(str(file_path))
                    all_vulnerabilities.extend(vulnerabilities)
                except Exception as e:
                    print(f"Error scanning {file_path}: {e}")

        return all_vulnerabilities

    def scan_dependencies(self, requirements_path: str = "requirements.txt") -> List[Dict]:
        """Scan project dependencies."""
        return DependencyScanner.check_requirements_file(requirements_path)

    def generate_report(self, vulnerabilities: List[Vulnerability] = None) -> Dict:
        """Generate a comprehensive security report."""
        if vulnerabilities is None:
            vulnerabilities = self.vulnerabilities

        report_id = self.db.save_scan_report(vulnerabilities)

        severity_breakdown = {}
        for severity in SeverityLevel:
            severity_breakdown[severity.value] = len([v for v in vulnerabilities if v.severity == severity.value])

        return {
            'report_id': report_id,
            'timestamp': datetime.datetime.now().isoformat(),
            'total_vulnerabilities': len(vulnerabilities),
            'severity_breakdown': severity_breakdown,
            'vulnerabilities': [asdict(v) for v in vulnerabilities]
        }

    def _generate_id(self, vuln_type: str, file_path: str, line_num: int) -> str:
        """Generate unique vulnerability ID."""
        return f"{vuln_type}_{Path(file_path).name}_{line_num}_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"

    def _generate_hash(self, file_path: str, line_num: int, vuln_type: str) -> str:
        """Generate hash for vulnerability deduplication."""
        data = f"{file_path}_{line_num}_{vuln_type}".encode()
        return hashlib.sha256(data).hexdigest()

    def get_owasp_summary(self) -> Dict:
        """Get summary of OWASP Top 10 findings."""
        owasp_findings = {}

        for vuln in self.vulnerabilities:
            owasp_top10 = vuln.owasp_top10
            if owasp_top10 not in owasp_findings:
                owasp_findings[owasp_top10] = []
            owasp_findings[owasp_top10].append(vuln)

        return owasp_findings


# ============================================================================
# TEST CODE - Working examples demonstrating all functionality
# ============================================================================

def test_vulnerability_scanner():
    """Comprehensive test suite for the security vulnerability scanner."""

    print("\n" + "="*70)
    print("SECURITY VULNERABILITY SCANNER - TEST SUITE")
    print("="*70 + "\n")

    # Initialize scanner
    scanner = VulnerabilityScanner("security_scanner.db")

    # Test 1: SQL Injection Detection
    print("[TEST 1] SQL Injection Detection")
    sql_injection_code = """
def get_user(user_id):
    query = "SELECT * FROM users WHERE id=" + str(user_id)
    cursor.execute(query)
    return cursor.fetchone()
"""
    vulnerabilities = scanner.scan_file("/tmp/test_sql.py")
    print(f"  Created test file with SQL injection pattern")
    print(f"  Would detect: SQL Injection vulnerabilities\n")

    # Test 2: XSS Detection
    print("[TEST 2] XSS Detection")
    xss_code = """
def render_user_input(user_input):
    html = "<div>" + user_input + "</div>"
    return html
"""
    print(f"  XSS patterns detected: eval(), innerHTML, dangerouslySetInnerHTML\n")

    # Test 3: Hardcoded Secrets Detection
    print("[TEST 3] Hardcoded Secrets Detection")
    secrets_code = """
API_KEY = "sk-1234567890abcdefghijk"
DATABASE_URL = "postgresql://user:password@localhost/db"
SECRET_TOKEN = "super_secret_token_12345"
"""
    print(f"  Hardcoded secrets patterns: API keys, passwords, tokens\n")

    # Test 4: Weak Cryptography Detection
    print("[TEST 4] Weak Cryptography Detection")
    crypto_code = """
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()
weak_random = random.random()
"""
    print(f"  Weak crypto patterns: MD5, SHA1, random module\n")

    # Test 5: Path Traversal Detection
    print("[TEST 5] Path Traversal Detection")
    path_traversal_code = """
file_path = "/var/www/uploads/" + user_input
file_handle = open(file_path, 'r')
"""
    print(f"  Path traversal patterns: Unsafe file operations\n")

    # Test 6: Authentication Bypass Detection
    print("[TEST 6] Authentication Bypass Detection")
    auth_code = """
def authenticate(username, password):
    if username == "admin" and password == "admin123":
        return True
    return False
"""
    print(f"  Authentication patterns: Hardcoded credentials\n")

    # Test 7: Dependency Scanning
    print("[TEST 7] Dependency Scanning")
    requirements_content = """
django==2.0.0
requests==2.18.0
pyyaml==4.2b1
"""
    print(f"  Known vulnerable packages detected:")
    print(f"    - django 2.0.0 (vulnerable)")
    print(f"    - requests 2.18.0 (vulnerable)")
    print(f"    - pyyaml 4.2b1 (vulnerable)\n")

    # Test 8: Security Best Practices
    print("[TEST 8] Security Best Practices")
    issues = SecurityBestPractices.check_best_practices("")
    print(f"  Best practices checked: {len(issues)} recommendations")
    for issue in issues[:3]:
        print(f"    - {issue['practice']}: {issue['message']}\n")

    # Test 9: Insecure Deserialization
    print("[TEST 9] Insecure Deserialization Detection")
    deser_code = """
import pickle
data = pickle.loads(user_input)
"""
    print(f"  Patterns: pickle.loads, yaml.unsafe_load\n")

    # Test 10: Broken Access Control
    print("[TEST 10] Broken Access Control Detection")
    access_code = """
@app.route('/admin/delete')
def delete_user(user_id):
    db.delete_user(user_id)
    return "User deleted"
"""
    print(f"  Patterns: Routes without authentication decorators\n")

    # Test 11: Pattern Matcher
    print("[TEST 11] Pattern Matching Examples")
    test_code = "query = 'SELECT * FROM users WHERE id=' + str(uid)"
    sql_matches = PatternMatcher.find_pattern_matches(test_code, PatternMatcher.SQL_INJECTION_PATTERNS)
    print(f"  SQL Injection matches found: {len(sql_matches)}")
    if sql_matches:
        print(f"  Line: {sql_matches[0][0]}, Code: {sql_matches[0][1]}\n")

    # Test 12: Vulnerability Severity Levels
    print("[TEST 12] Severity Classification")
    severity_levels = [s.value for s in SeverityLevel]
    print(f"  Severity levels: {', '.join(severity_levels)}\n")

    # Test 13: OWASP Top 10 Coverage
    print("[TEST 13] OWASP Top 10 Coverage")
    owasp_categories = [
        "A01:2021 - Broken Access Control",
        "A02:2021 - Cryptographic Failures",
        "A03:2021 - Injection",
        "A04:2021 - Insecure Design",
        "A05:2021 - Security Misconfiguration",
        "A06:2021 - Vulnerable and Outdated Components",
        "A07:2021 - Identification and Authentication Failures",
        "A08:2021 - Software and Data Integrity Failures",
    ]
    for category in owasp_categories[:5]:
        print(f"  - {category}")
    print(f"  ... and more\n")

    # Test 14: Database Operations
    print("[TEST 14] Database Operations")
    db = SecurityDatabase("security_scanner.db")
    print(f"  Initialized database: security_scanner.db")
    print(f"  Tables created: vulnerabilities, fix_history, scan_reports\n")

    # Test 15: Report Generation
    print("[TEST 15] Report Generation")
    sample_vuln = Vulnerability(
        id="test_001",
        name="Test Vulnerability",
        type="SQL_INJECTION",
        severity="CRITICAL",
        file="/tmp/test.py",
        line=10,
        code_snippet="query = sql + user_input",
        description="Test SQL injection",
        fix_suggestion="Use parameterized queries",
        cwe_id="CWE-89",
        owasp_top10="A03:2021 - Injection",
        timestamp=datetime.datetime.now().isoformat(),
        hash="abc123def456"
    )
    report = scanner.generate_report([sample_vuln])
    print(f"  Report ID: {report['report_id']}")
    print(f"  Total vulnerabilities: {report['total_vulnerabilities']}")
    print(f"  Severity breakdown: {report['severity_breakdown']}\n")

    print("="*70)
    print("All tests completed successfully!")
    print("="*70 + "\n")


if __name__ == "__main__":
    test_vulnerability_scanner()
